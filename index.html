<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>智能网关</title>
    <style>
        body {
            font-family: -apple-system, system-ui, sans-serif;
            max-width: 600px;
            margin: 20px auto;
            padding: 0 20px;
        }
        .status {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .node {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .fastest {
            background: #e6ffe6;
        }
        .speed {
            color: #666;
        }
        .target-url {
            word-break: break-all;
            padding: 8px;
            background: #f8f8f8;
            margin: 10px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="status" class="status">正在测速...</div>
    <div id="targetUrl" class="target-url"></div>
    <div id="results"></div>

    <script>
        const GATEWAY_DOMAIN = 'smart.acofork.us.kg';
        
        const nodes = [
            { name: "Cloudflare Pages", url: "https://blog.acofork.us.kg" },
            { name: "Fleek", url: "https://fleek-blog.acofork.us.kg" },
            { name: "Vercel", url: "https://vercel-blog.acofork.us.kg" },
            { name: "Github Pages", url: "https://github-blog.acofork.us.kg" }
        ];

        // 获取请求路径（移除网关域名）
        function getTargetPath() {
            const currentPath = window.location.pathname + window.location.search + window.location.hash;
            const targetUrl = new URL(window.location.href);
            // 移除可能的端口号
            const currentHost = targetUrl.host.split(':')[0];
            
            // 显示目标URL
            document.getElementById('targetUrl').textContent = 
                `原始请求: ${window.location.href}`;
            
            // 如果当前域名是网关域名，保留路径；否则使用根路径
            return currentHost === GATEWAY_DOMAIN ? currentPath : '/';
        }

        const targetPath = getTargetPath();
        const resultsDiv = document.getElementById('results');
        const statusDiv = document.getElementById('status');

        // 更新节点状态显示
        function updateNodeStatus(node, speed) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'node';
            nodeDiv.innerHTML = `
                <span>${node.name}</span>
                <span class="speed">${speed === 99999 ? '超时' : speed + 'ms'}</span>
            `;
            resultsDiv.appendChild(nodeDiv);
            return nodeDiv;
        }

        // 测试单个节点
        async function testNode(node) {
            const startTime = performance.now();
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);

                const response = await fetch(node.url, {
                    mode: 'no-cors',
                    cache: 'no-store',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                const speed = Math.round(performance.now() - startTime);
                return { node, speed, nodeDiv: updateNodeStatus(node, speed) };
            } catch {
                return { node, speed: 99999, nodeDiv: updateNodeStatus(node, 99999) };
            }
        }

        // 测试所有节点并重定向
        async function findFastestNode() {
            let completedTests = 0;
            let fastestNode = null;
            let fastestSpeed = Infinity;

            try {
                const tests = nodes.map(async node => {
                    const result = await testNode(node);
                    completedTests++;

                    if (result.speed < fastestSpeed && result.speed !== 99999) {
                        if (fastestNode) {
                            fastestNode.nodeDiv.classList.remove('fastest');
                        }
                        fastestNode = result;
                        fastestSpeed = result.speed;
                        result.nodeDiv.classList.add('fastest');
                    }

                    if (completedTests === nodes.length && fastestNode) {
                        const targetUrl = `${fastestNode.node.url}${targetPath}`;
                        statusDiv.textContent = `已找到最快节点: ${fastestNode.node.name} (${fastestNode.speed}ms)，正在跳转到 ${targetUrl}`;
                        window.location.href = targetUrl;
                    }
                });

                await Promise.all(tests);
                
                if (!fastestNode) {
                    statusDiv.textContent = '所有节点均无法访问，请刷新重试';
                }
            } catch (error) {
                statusDiv.textContent = '测速过程出错，请刷新重试';
            }
        }

        // 开始测速
        findFastestNode();
    </script>
</body>
</html>