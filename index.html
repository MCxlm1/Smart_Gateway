<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>智能网关</title>
    <style>
        body {
            font-family: -apple-system, system-ui, sans-serif;
            max-width: 600px;
            margin: 20px auto;
            padding: 0 20px;
        }
        .status {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .node {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .fastest {
            background: #e6ffe6;
        }
        .error {
            background: #ffe6e6;
        }
        .speed {
            color: #666;
        }
        .http-status {
            margin-left: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        .status-ok {
            background: #e6ffe6;
            color: #008000;
        }
        .status-error {
            background: #ffe6e6;
            color: #cc0000;
        }
        .target-url {
            word-break: break-all;
            padding: 8px;
            background: #f8f8f8;
            margin: 10px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="status" class="status">正在测速及检查节点状态...</div>
    <div id="targetUrl" class="target-url"></div>
    <div id="results"></div>

    <script>
        const GATEWAY_DOMAIN = 'smart.acofork.us.kg';
        
        const nodes = [
            { name: "Cloudflare Pages", url: "https://blog.acofork.us.kg" },
            { name: "Fleek", url: "https://fleek-blog.acofork.us.kg" },
            { name: "Vercel", url: "https://vercel-blog.acofork.us.kg" },
            { name: "Github Pages", url: "https://github-blog.acofork.us.kg" }
        ];

        // 获取请求路径
        function getTargetPath() {
            const currentPath = window.location.pathname + window.location.search + window.location.hash;
            const targetUrl = new URL(window.location.href);
            const currentHost = targetUrl.host.split(':')[0];
            
            document.getElementById('targetUrl').textContent = 
                `原始请求: ${window.location.href}`;
            
            return currentHost === GATEWAY_DOMAIN ? currentPath : '/';
        }

        const targetPath = getTargetPath();
        const resultsDiv = document.getElementById('results');
        const statusDiv = document.getElementById('status');

        // 更新节点状态显示
        function updateNodeStatus(node, speed, httpStatus) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'node';
            
            const statusClass = httpStatus === 200 ? 'status-ok' : 'status-error';
            const statusText = httpStatus === 200 ? 'OK' : `错误 ${httpStatus}`;
            
            nodeDiv.innerHTML = `
                <span>${node.name}</span>
                <span>
                    <span class="speed">${speed === 99999 ? '超时' : speed + 'ms'}</span>
                    <span class="http-status ${statusClass}">${statusText}</span>
                </span>
            `;
            resultsDiv.appendChild(nodeDiv);
            return nodeDiv;
        }

        // 测试单个节点
        async function testNode(node) {
            const startTime = performance.now();
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);

                // 测试实际请求路径而不是根路径
                const testUrl = `${node.url}${targetPath}`;
                const response = await fetch(testUrl, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                const speed = Math.round(performance.now() - startTime);
                
                // 返回完整状态，包括 HTTP 状态码
                return { 
                    node, 
                    speed, 
                    httpStatus: response.status,
                    nodeDiv: updateNodeStatus(node, speed, response.status)
                };
            } catch (error) {
                // 捕获网络错误或超时
                return { 
                    node, 
                    speed: 99999, 
                    httpStatus: 0,
                    nodeDiv: updateNodeStatus(node, 99999, 0)
                };
            }
        }

        // 测试所有节点并重定向
        async function findFastestNode() {
            let completedTests = 0;
            let fastestNode = null;
            let fastestSpeed = Infinity;

            try {
                const tests = nodes.map(async node => {
                    const result = await testNode(node);
                    completedTests++;

                    // 只有当状态码为 200 时才考虑该节点
                    if (result.speed < fastestSpeed && result.httpStatus === 200) {
                        if (fastestNode) {
                            fastestNode.nodeDiv.classList.remove('fastest');
                        }
                        fastestNode = result;
                        fastestSpeed = result.speed;
                        result.nodeDiv.classList.add('fastest');
                    } else if (result.httpStatus !== 200) {
                        result.nodeDiv.classList.add('error');
                    }

                    // 所有测试完成后，如果找到可用节点则跳转
                    if (completedTests === nodes.length && fastestNode) {
                        const targetUrl = `${fastestNode.node.url}${targetPath}`;
                        statusDiv.textContent = `已找到最快可用节点: ${fastestNode.node.name} (${fastestNode.speed}ms, HTTP ${fastestNode.httpStatus})，正在跳转...`;
                        window.location.href = targetUrl;
                    } else if (completedTests === nodes.length) {
                        statusDiv.textContent = '未找到可用节点，请稍后重试';
                    }
                });

                await Promise.all(tests);
            } catch (error) {
                statusDiv.textContent = '测试过程出错，请刷新重试';
            }
        }

        // 开始测速
        findFastestNode();
    </script>
</body>
</html>